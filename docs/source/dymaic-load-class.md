# 类的动态加载

- 为什么要动态地加载类或者说什么时候需要动态地加载类？
- 动态加载类的原理是什么？

### java中的类加载器

java的类加载器们都有自己的类名称空间，只有和类加载器位于同一个类名称空间的类才能够被加载器加载。

**问：java当中都有哪些类加载器呢？**

答：java当中主要有启动类加载器、扩展类加载器、应用程序类加载器、自定义类加载器共四种加载器。

![img](https://pic1.zhimg.com/80/v2-c8e5a55b021fe4df1573e06915a21c9c_1440w.webp)

**问：什么是启动类加载器？**

答：这是唯一一个用c++开发的类加载器，用来加载 <JAVA_HOME>/lib目录下的jar和tools.jar 或是使用 -Xbootclasspath 参数指定的类。



### 类加载的过程

**问：java中如何进行类的动态加载？**

答：通过调用 java.lang.ClassLoader 中的 LoadCLass() 方法完成类的动态加载。

问：LoadCLass() 方法加载类的具体过程是怎样的？其背后的原理/依据是什么？

答：java中类的动态加载是根据双亲委派模型进行的。

**问：什么是双亲委派模型？**

答：双亲委派指的是当类加载器尝试加载某类时，会首先调用父类加载器来加载类，如果父类加载器无法加载才尝试自己加载类。具体过程可以概括如下：

1. 接收到一个类加载请求，首先判断该类是否已加载，若已加载则直接返回。
2. 如果尚未加载，那么则尝试获取父类加载器并调用父类的 loadClass() 方法加载类。如果无法成功获取父类加载器，那么则调用启动类加载器来加载。
3. 最后，判断类是否已被父类加载器或启动类加载器加载，如果都没有，则尝试自己加载类。

- 注意，父类加载器也会尝试交给自己的父类加载器加载，所以这是一个套娃的过程，直到遇见顶层的启动类加载器才停止。

具体到java的各个类加载器的话，总体的类加载过程是 BOOT —> EXC —-> APP

**问：为什么要采用双亲委派模型来进行类的加载？**

答：使用双亲委派模型加载类使得每个类都尽可能地被顶层的类加载器加载，这可以保证类加载的唯一性，这对于java程序的稳定运行意义重大。（所以到底是什么意义？🤭）

### 具体示例

idea新建一个名为 java.lang 的 package，然后在该 package 下新建一个名为 String.java 的类文件。之后编写如下代码：

```java
package java.lang;

public class String {
    public String toString(){
        return "hello";

    }
    public static void main(String[] args){
        String s = new String();
        s.toString();

    }
}
```

运行之后发现报错提示找不到main()方法？！

**问：为什么上述代码运行之后报错且没有找到main()方法？明明定义了main()方法的！**

答：和双亲委派模型有关，上面的String类是由哪个类加载器加载的呢？没错就是顶层的启动类加载器 Boostrap ClassLoader。

那到底为什么会报错呢？因为在这个类加载器的类名称空间中，也有一个名为 String 的类。在启动类加载器加载我们定义的 String 类时，其在自己的名称空间中发现了同名的 String 类，于是乎该加载器就直接加载了 String 类，但是这一个 String 类是没有 main() 方法滴，所以这就是为什么上面代码报错的终极原因！

**问：如果定义一个在启动类加载器的类名称空间中没有的类会怎样？**

```java
package org.example;

public class String {
    public java.lang.String toString(){
        return "hello";

    }
    public static void main(java.lang.String[] args){
        String s = new String();
        System.out.println(s.toString());
        System.out.println(s.getClass().getClassLoader());

    }
}
```

## Java中的代码块

**1. 问：java中都有哪些代码块呢？**

答：静态代码块、构造代码块、无参构造器、有参构造器。



**2. 问：静态代码块是什么？**

答：静态代码块就是用 static 关键字结合花括号括起来的代码块。

```
    static {
        System.out.println("静态代码块");

    }
```

静态代码块就是无论你调用什么静态方法，都会先调用静态方法



**3. 问：什么是构造代码块？构造代码块有什么性质吗？**

答：构造代码块就是类中直接用花括号括起来而括号前面没有 static 关键字的一段代码块

```
    {
        System.out.println("构造代码块");

    }
```

构造代码块的性质就是无论调用什么构造方法，都会自动调用构造代码块。



**问：什么是无参构造器？**

答：就是无参构造函数。



**问：什么是有参构造器？**

答：就是有参构造函数。



**问：实例化对象时，上述四个代码块的执行顺序是怎样的？**

答：通过 new 关键字实例化对象的时候，先调用静态代码块，再调用构造代码块，最后才是调用有参或者无参构造器。



